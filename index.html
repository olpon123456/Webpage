<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Decoded ad URL</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,Arial,-apple-system,Segoe UI;display:flex;align-items:center;justify-content:center;background:#111;color:#fff}
    .center{max-width:900px;padding:24px;text-align:center}
    .url{word-break:break-all;font-size:20px;background:#0b0b0b;padding:18px;border-radius:8px;border:1px solid #222}
    .msg{opacity:.85;margin-top:12px;font-size:14px;color:#ddd}
    /* Hidden iframe used for decoding */
    iframe#decoderFrame{display:none !important;width:1px;height:1px;border:0;position:absolute;left:-9999px;top:-9999px}
  </style>
</head>
<body>
  <div id="root" class="center">
    <div id="loading" class="msg">Decoding ad loader — waiting for decoded ad URL...</div>
  </div>

  <!-- hidden sandboxed iframe where loader runs and atob() is intercepted -->
  <iframe id="decoderFrame" sandbox="allow-scripts"></iframe>

  <script>
  (function(){
    const LOADER_URL = 'https://webpage-76ur.onrender.com/get-adcode'; // change if needed
    const TIMEOUT_MS = 10000; // how long to wait for decode before showing error
    const root = document.getElementById('root');
    const loadingEl = document.getElementById('loading');
    const iframe = document.getElementById('decoderFrame');

    // Utility to replace page content with a single message (decoded URL or error)
    function showOnlyMessage(title, message, sub){
      document.title = title || document.title;
      root.innerHTML = '';
      const box = document.createElement('div');
      box.style.display = 'flex';
      box.style.flexDirection = 'column';
      box.style.alignItems = 'center';
      box.style.justifyContent = 'center';
      const urlEl = document.createElement('div');
      urlEl.className = 'url';
      urlEl.textContent = message;
      box.appendChild(urlEl);
      if(sub){
        const subEl = document.createElement('div');
        subEl.className = 'msg';
        subEl.textContent = sub;
        box.appendChild(subEl);
      }
      root.appendChild(box);
    }

    // Build iframe srcdoc that intercepts atob and posts decoded strings to parent
    function buildSrcdoc(loaderSourceEscaped){
      return `
<!doctype html>
<html>
  <head><meta charset="utf-8"><title>decoder-frame</title></head>
  <body>
    <script>
      (function(){
        // small safe logger
        function innerLog(m){ try{ /* no-op visual logs inside hidden iframe */ }catch(e){} }

        // intercept atob: post decoded strings to parent
        const nativeAtob = window.atob;
        window.atob = function(s){
          const decoded = nativeAtob.call(this, s);
          try{ parent.postMessage({type:'atob-decoded', decoded: decoded}, '*'); }catch(e){}
          innerLog('[atob] ' + decoded);
          return decoded;
        };

        // forward console messages back to parent (optional)
        const rawLog = console.log;
        console.log = function(){
          try{ parent.postMessage({type:'console', args: Array.from(arguments)}, '*'); }catch(e){}
          rawLog.apply(console, arguments);
        };

        // Run the loader code we injected from parent:
        try{
          ${loaderSourceEscaped}
        }catch(e){
          try{ parent.postMessage({type:'loader-error', message: String(e)}, '*'); }catch(err){}
        }
      })();
    </script>
  </body>
</html>
`;
    }

    // Start decode process immediately
    (async function start(){
      loadingEl.textContent = 'Fetching loader...';
      let codeText = null;
      try{
        const res = await fetch(LOADER_URL, {mode:'cors'});
        if(!res.ok) throw new Error('fetch failed: ' + res.status);
        codeText = await res.text();
      }catch(err){
        showOnlyMessage('Decode error', 'Failed to fetch loader', String(err));
        return;
      }

      // Prepare loader source for embedding safely into srcdoc
      // Escape backticks and </script> sequences
      const escaped = codeText.replace(/`/g,'\\`').replace(/<\\/script>/gi,'<\\\\/script>');
      iframe.srcdoc = buildSrcdoc(escaped);
      loadingEl.textContent = 'Loader loaded in sandbox — waiting for atob decode...';

      // Set timeout in case nothing decodes
      const t = setTimeout(()=>{
        showOnlyMessage('No decoded URL', 'No URL decoded within timeout (' + (TIMEOUT_MS/1000) + 's).', 'Check loader or CORS.');
      }, TIMEOUT_MS);

      // Listen for decoded messages from iframe
      function onMessage(ev){
        try{
          const d = ev.data || {};
          if(d && d.type === 'atob-decoded'){
            // First choose the decoded value that looks like a URL
            const decoded = String(d.decoded || '').trim();
            if(!decoded){
              // ignore empty, keep waiting
              return;
            }

            // prefer first https? URL; otherwise use the first decoded content
            if(/^https?:\\/\\//i.test(decoded)){
              clearTimeout(t);
              window.removeEventListener('message', onMessage);
              showOnlyMessage('Decoded ad URL', decoded, 'Decoded from loader atob()');
            } else {
              // if not a URL, we may still show it (fallback)
              // but continue listening for potential URL decodes
              // show temporarily but continue waiting for a URL until timeout
              showOnlyMessage('Decoded (non-URL)', decoded, 'No URL yet — waiting for https:// decode until timeout');
            }
          } else if(d && d.type === 'loader-error'){
            clearTimeout(t);
            window.removeEventListener('message', onMessage);
            showOnlyMessage('Loader error', d.message || 'Unknown loader error');
          } else if(d && d.type === 'console'){
            // ignore console forwards
          }
        }catch(e){
          // ignore parsing issues
        }
      }
      window.addEventListener('message', onMessage);
    })();
  })();
  </script>
</body>
</html>